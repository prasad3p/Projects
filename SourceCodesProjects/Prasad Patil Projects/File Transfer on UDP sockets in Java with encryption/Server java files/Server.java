package serverApplications;

import java.io.IOException;
import java.net.DatagramPacket;
import java.net.DatagramSocket;
import java.nio.charset.StandardCharsets;
import java.nio.file.Files;
import java.nio.file.Paths;
import java.util.regex.Pattern;


public class Server {

	private final static String PROTOCOL="ENTS/1.0 Response";
	//[CR+LF] is denoted here by SEPARATOR.
	private final static String SEPARATOR="\r\n";
	private String checksumGenerated;
	private String checksumReceived;
	private String responseCode;
	private String contentLength;
	private String resposeMsg;
	private String fileContent;
	private String resposeChecksum;


	public void receiveMsg() throws Exception 
	{
		// TODO Auto-generated method stub
		DatagramSocket DS = null;
        DS = new DatagramSocket(7006);
        //Buffer to receive incoming data
        byte[] B = new byte[8000];
        DatagramPacket req = new DatagramPacket(B, B.length);
        while(true)
        {
            	
            	System.out.println("Waiting for a message from client..");
            	//Receive message from client
                DS.receive(req);
                byte[] data = req.getData();
                
                //Convert received bytes into a single string
                String s = new String(data, 0, req.getLength());
                System.out.println("The received message is:\n"+s);
                
                //Split the received message at [CR+LF] i.e \r\n
                String X[]=s.split("\r\n");
                
                //Save the received checksum 
                this.setChecksumReceived(X[2]+"\r\n");
                
                //CharacterFitting() method fits two consecutive characters of a string into a single 16 bit word. And returns an array of such 16 bit words.
                //Here X[0] is 'Protocol' and X[1] is 'Filename.extension'
        		short []J=this.charactersFitting((X[0]+"\r\n"+X[1]+"\r\n"));
        		//Array of such 16 bit words is then used to generated checksum. Checksum is generated by the method call generateChecksum()
        		short S=this.generateChecksum(J);
        		//Save generated checksum as a string
        		this.setChecksumGenerated(String.valueOf(S));
        		//Append [CR+LF] to locally generated checksum and set it to locally generated checksum
            	this.setChecksumGenerated(this.getChecksumGenerated()+"\r\n");
                
            	//Check if locally generated checksum is equal to received checksum 
            	if(this.getChecksumGenerated().equals(this.getChecksumReceived()))
                {
	                
	                
                	System.out.println("Integrity check: SUCCESS");
                	//Check syntax of the message received as well the filename 
                	if(this.checkSyntax(s)==true)
                	{
                		System.out.println("Syntax check: SUCCESS");
                		//Check protocol version
                		if(this.checkProtocol(s)==true)
                		{
                			System.out.println("Protocol version check: SUCCESS");
                			//Fetch content of the file and set response code to 0
                			if(this.getFileContent(s)==true)
                			{	
                				System.out.println("File content fetch: SUCCESS");
                				this.setResponseCode("0\r\n");
                				
                			}
                			//Set response code to 3 if file content fetching fails
                			else
                			{
                				System.out.println("File content fetch: FAILED");
                				this.setResponseCode("3\r\n");
                				
                			}
                		}
                		//Set response code to 4 if protocol version is incorrect
                		else
                		{
                			System.out.println("Protocol version check: FAILED");
                    		this.setResponseCode("4\r\n");
                		}
        
                	}
                	//Set response code to 2 if file syntax is incorrect
                	else
                	{
                		System.out.println("Syntax check: FAILED");
                		this.setResponseCode("2\r\n");
                		
                	}
                }
            	//Set response code to 1 if integrity check fails
                else
                {
                	System.out.println("Integrity check: FAILED");
                	this.setResponseCode("1\r\n");
                	
	                
                }
            	//Generate response based on corresponding response code and requested file.
                this.generateResponse();
            	System.out.println("\nResponse message is:\n"+ this.getResposeMsg());
            	
            	//Convert response  message string into byte array and send it to the client
            	byte[] bytes = this.getResposeMsg().getBytes();
                DatagramPacket SND = new DatagramPacket(bytes , bytes.length , req.getAddress() , req.getPort());
                System.out.println("Rsponse sent to the client\n");
                DS.send(SND);
          }
	}
	//Function to extract file content of the requested file.
	private boolean getFileContent(String receivedMsg)  {
		// TODO Auto-generated method stub
		String g[]=receivedMsg.split("\r\n");
		//Path definition where all the files are located
		String pathl="C:/Users/Toshiba/Desktop/Patil/us/UMCP/640/project/"+g[1];
		
		try 
		{
			//Read the file content and put all the content into a single string called 'text'
			String text = new String(Files.readAllBytes(Paths.get(pathl)), StandardCharsets.UTF_8);
			this.setFileContent(text+"\r\n");
			this.setContentLength(Integer.toString(text.length())+"\r\n");
		} 
		catch (IOException e) 
		{
			//Return false if content fetching fails
			return false;
		}
		
		//Return true otherwise
		return true;
	}
	
	//Function to check protocol version
	private boolean checkProtocol(String receivedMsg) {
		// TODO Auto-generated method stub
		//Compare 5th and 7th character to 1 and 0 respectively. For protocol version to be correct
		if(receivedMsg.charAt(5) != this.getProtocol().charAt(5) || receivedMsg.charAt(7) !=this.getProtocol().charAt(7))
			return false;
		
		return true;
	}
	
	//Check syntax of the request message
	private boolean checkSyntax(String receivedMsg) {
		// TODO Auto-generated method stub
		String g[]=receivedMsg.split("\r\n");
		
		String h[]=g[1].split("\\.");
		//Check if filename is in <filename.extension> format
		if(h.length!=2)
    		return false;
		
		//Check if request message has exactly 3 fields including checksum.
		if(g.length!=3)
    		return false;
    		
    	Pattern p = Pattern.compile("[^a-zA-Z0-9_]");
    	//Check if filename contains special characters, or it starts with a number or it starts with an underscore
    	if(p.matcher(h[0]).find()==true || Character.isDigit(h[0].charAt(0)) || h[0].charAt(0)=='_')
    		return false;
    	
    	Pattern p1 = Pattern.compile("[^a-zA-Z0-9]");
    	//Check if file extension contains anythings other than alphabets and numbers
    	if(p1.matcher(h[1]).find()==true || !(h[1].equals("txt")))
    		return false;
    	
    	return true;
	}

	//Funciton to generate response message based on response code
	private void generateResponse() {
		// TODO Auto-generated method stub
		if(this.getResponseCode().equals("1\r\n") || this.getResponseCode().equals("2\r\n") || this.getResponseCode().equals("3\r\n")||  this.getResponseCode().equals("4\r\n") )
		{	
			this.setContentLength("0\r\n");
			this.setFileContent(""+"\r\n");
		}
		//Call the function characterFitting() to fit two consecutive characters of a string into a single 16 bit word.And returns an array of such 16 bit words.
		short []J=this.charactersFitting(this.getProtocol()+Server.getSeperator()+this.getResponseCode()+this.getContentLength()+this.getFileContent());
		//Generate checksum based on array of 16 bit words generated in the previous step
		short S=this.generateChecksum(J);
    	this.setResposeChecksum(String.valueOf(S));
    	this.setResposeChecksum(this.getResposeChecksum()+"\r\n");
    	//Set response message
		this.setResposeMsg(this.getProtocol()+Server.getSeperator()+this.getResponseCode()+this.getContentLength()+this.getFileContent()+this.getResposeChecksum());
		
	}

	//Function to fit two consecutive characters of a string into a single 16 bit work. Do it for the whole string.
	private short[] charactersFitting(String msg) {
		// TODO Auto-generated method stub
		//Save message length in N
		int N=msg.length();
    	int j=0;
    	
    	//Check if message length is even
    	if(N%2==0)
    	{
    	
    		/*if N length is even, then length of array is set to N/2. As two characters are fit into single word, 
   		 	length of array will be half of the length string*/
    		N=N/2;
    		short[] div= new short [N];
    		
    		for(int i=0;i<N;i++)
        	{
    			/*To fit two consecutive characters in a single 16 bit word, left shift first character by 8 and 'or' that with the next character
  			  continue this for the length of the string*/
        		div[i]=(short) ((msg.charAt(j)<<8) | msg.charAt(j+1));	
        		//Use indexing that will shift the position to access string in alternate ways (0,2,4 and so on)
        		j+=2;
        	}
    		return(div);
    	}
    	else
    	{
    		//if length is odd then array length is set to N/2 + 1. As the last character has to be 'or'ed with 0.
    		N=(N/2)+1;
    		short[] div= new short [N];
    		for(int i=0;i<N;i++)
        	{
    			//Check if index has reached the last character. If yes then 'or' the last character with 0.
        		if(j==msg.length()-1)
        		{
        			
        			div[i]=(short) ((msg.charAt(j)<<8) | 0x0000);
        			break;
        		}
        		/*To fit two consecutive characters in a single 16 bit word, left shift first character by 8 and 'or' that with the next character
  			  	continue this for the length of the string*/
        		div[i]=(short) ((msg.charAt(j)<<8) | msg.charAt(j+1));
        		//Use indexing that will shift the position to access string in alternate ways (0,2,4 and so on)
        		j+=2;
        	}
    		return(div);
    	}
	}

	//Function to generate checksum
	private short generateChecksum(short[] div) {
		// TODO Auto-generated method stub
		short S=0,index=0;
    	int C=7919;
    	int D=65536;
    	
    	for(int i=0;i<div.length;i++)
    	{
    		index=(short) (S ^ div[i]);
    		S=(short) (C*index);
    		//Modulo adjustment
    		if(S>D)
    			S-=(D+1);
    	}
    	return S;
	}
	
	//Setters and getters of all the fields declared for this class
	
	public String getProtocol() {
		return PROTOCOL;
	}
	public String getChecksumGenerated() {
		return checksumGenerated;
	}

	public void setChecksumGenerated(String checksum) {
		this.checksumGenerated = checksum;
	}
	public String getChecksumReceived() {
		return checksumReceived;
	}
	public void setChecksumReceived(String checksumReceived) {
		this.checksumReceived = checksumReceived;
	}
	public String getResponseCode() {
		return responseCode;
	}

	public void setResponseCode(String responseCode) {
		this.responseCode = responseCode;
	}

	public String getContentLength() {
		return contentLength;
	}

	public void setContentLength(String contentLength) {
		this.contentLength = contentLength;
	}

	public String getResposeMsg() {
		return resposeMsg;
	}

	public void setResposeMsg(String resposeMsg) {
		this.resposeMsg = resposeMsg;
	}

	public String getFileContent() {
		return fileContent;
	}

	public void setFileContent(String content) {
		this.fileContent = content;
	}

	public String getResposeChecksum() {
		return resposeChecksum;
	}

	public void setResposeChecksum(String resposeChecksum) {
		this.resposeChecksum = resposeChecksum;
	}
	public static String getSeperator() {
		return SEPARATOR;
	}
}
